# AI rules for Flutter

You are an expert in Flutter and Dart development. Your goal is to build
beautiful, performant, and maintainable applications following modern best
practices. You have expert experience with application writing, testing, and
running Flutter applications for various platforms, including desktop, web, and
mobile platforms.

# AI Instructions for PCQ FIR Pilot App

You are an expert Flutter developer working on the **PCQ FIR Pilot App**, a gate pass management system built with Flutter 3.9.0+ and Dart 3.9.0+. This document provides comprehensive guidelines for maintaining consistency and following the established patterns in this specific project.

## 📋 Project Context

### Application Overview
The PCQ FIR Pilot App is a production-grade Flutter application for managing gate passes with features including:
- Real-time network connectivity monitoring with overlay-based offline handling
- QR code scanning for gate pass verification
- Item scanning and verification workflow
- Real-time analytics dashboard with charts
- Dark/Light theme support with Material 3 design

### Core Technology Stack
```yaml
# State Management & Navigation
flutter_riverpod: ^3.0.1        # AsyncNotifier pattern for state management
go_router: ^16.2.4               # Declarative, type-safe routing

# Network & Connectivity
connectivity_plus: ^7.0.0        # Real-time network monitoring
dio: ^5.9.0                      # HTTP client with interceptors

# UI & Visualization
iconsax: ^0.0.8                  # Icon library
fl_chart: ^0.69.0                # Interactive charts
cached_network_image: ^3.4.1     # Image caching

# Data & Storage
shared_preferences: ^2.3.5       # Local key-value storage
intl: ^0.20.2                    # Date formatting & i18n
```

## Interaction Guidelines
* **User Persona:** Assume the user is familiar with Flutter and Riverpod patterns specific to this project
* **Explanations:** Reference existing code patterns from the project when suggesting changes
* **Clarification:** If a request is ambiguous, check existing implementations in similar features first
* **Dependencies:** All new dependencies must be justified and aligned with the current tech stack
* **Formatting:** Use `dart format` to ensure consistent code formatting
* **Fixes:** Use `dart fix` for automatic code improvements
* **Linting:** Follow the `flutter_lints` rules configured in `analysis_options.yaml`

## 🏗️ Project Architecture

### Directory Structure
```
lib/
├── main.dart                    # App entry point with ProviderScope
├── app.dart                     # Root app widget with ConnectivityWrapper
├── core/                        # Core utilities and configuration
│   ├── constants/               # App-wide constants
│   │   ├── app_colors.dart      # Color palette with k prefix
│   │   └── app_themes.dart      # Light/Dark theme configuration
│   ├── extensions/              # Dart extensions
│   │   ├── datetime_extension.dart
│   │   └── sizedbox_extension.dart
│   ├── network/                 # Network layer
│   │   └── api_client.dart      # Dio client with ApiState pattern
│   ├── router/                  # Navigation
│   │   ├── app_router.dart      # GoRouter configuration
│   │   └── app_routes.dart      # Route constants
│   └── utils/                   # Utility functions
│       ├── custom_dialog.dart   # Dialog utilities
│       └── custom_snackbar.dart # Snackbar utilities
├── presentation/                # UI Layer
│   ├── features/                # Feature modules
│   │   ├── auth/                # Authentication module
│   │   ├── dashboard/           # Dashboard module
│   │   ├── gatepass/            # Gate pass module
│   │   └── connectivity/        # Connectivity monitoring
│   └── widgets/                 # Reusable widgets
│       ├── custom_button_widget.dart
│       ├── custom_scaffold.dart
│       ├── custom_text_field.dart
│       ├── custom_dropdown.dart
│       └── custom_cached_network_image.dart
├── repos/                       # Repository layer
│   ├── gatepass_repo.dart       # Gate pass data operations
│   └── member_repo.dart         # Member data operations
└── services/                    # Service layer
    ├── connectivity_service.dart # Network monitoring service
    └── shared_preferences_service.dart # Local storage service
```

### Feature Module Organization
Each feature follows a consistent structure:
```
feature_name/
├── models/                      # Data models
├── providers/                   # Riverpod providers (AsyncNotifier)
├── view/                        # Screens
│   ├── feature_screen.dart
│   └── widgets/                 # Feature-specific widgets
│       └── feature_screen/
```

## Project Structure
* **Standard Structure:** Assumes a standard Flutter project structure with
  `lib/main.dart` as the primary application entry point.

## 🎯 State Management Patterns (Riverpod)

### AsyncNotifier Pattern (PRIMARY PATTERN)
This project uses **AsyncNotifier** as the primary state management pattern. All business logic providers must follow this pattern.

#### State Class Pattern
```dart
/// State class with immutable properties
class FeatureState {
  final bool isLoading;
  final String? error;
  final DataModel? data;
  final bool isSuccess;

  const FeatureState({
    this.isLoading = false,
    this.error,
    this.data,
    this.isSuccess = false,
  });

  // Always include copyWith for immutability
  FeatureState copyWith({
    bool? isLoading,
    String? error,
    DataModel? data,
    bool? isSuccess,
  }) {
    return FeatureState(
      isLoading: isLoading ?? this.isLoading,
      error: error,  // Allow null to clear error
      data: data ?? this.data,
      isSuccess: isSuccess ?? this.isSuccess,
    );
  }
}
```

#### AsyncNotifier Implementation
```dart
/// AsyncNotifier for feature business logic
class FeatureNotifier extends AsyncNotifier<FeatureState> {
  @override
  Future<FeatureState> build() async {
    // Initialize with default or persisted state
    return const FeatureState();
  }

  /// Business logic method
  Future<void> performAction() async {
    // Set loading state
    state = const AsyncValue.data(FeatureState(isLoading: true));

    try {
      // Get dependencies from ref
      final repo = ref.read(featureRepoProvider);
      
      // Call repository
      final result = await repo.fetchData();

      // Handle API response using ApiState pattern
      if (result is ApiSuccess<DataModel>) {
        state = AsyncValue.data(
          FeatureState(isLoading: false, data: result.data, isSuccess: true),
        );
      } else if (result is ApiError<DataModel>) {
        state = AsyncValue.data(
          FeatureState(isLoading: false, error: result.message),
        );
      }
    } catch (e) {
      state = AsyncValue.data(
        FeatureState(isLoading: false, error: e.toString()),
      );
    }
  }

  /// Reset state
  void reset() {
    state = const AsyncValue.data(FeatureState());
  }
}

/// Provider declaration
final featureProvider = AsyncNotifierProvider<FeatureNotifier, FeatureState>(
  () => FeatureNotifier(),
);
```

### Provider Types and Usage

#### 1. AsyncNotifierProvider (Business Logic)
Use for complex state with async operations:
```dart
// Example: Dashboard Provider (see lib/presentation/features/dashboard/providers/dashboard_provider.dart)
final dashboardProvider = AsyncNotifierProvider<DashboardNotifier, DashboardState>(
  () => DashboardNotifier(),
);
```

#### 2. NotifierProvider (Simple State)
Use for simple synchronous state:
```dart
// Example: Action Type Provider (see lib/presentation/features/dashboard/providers/action_type_provider.dart)
final actionTypeProvider = NotifierProvider<ActionTypeNotifier, ActionType>(
  () => ActionTypeNotifier(),
);
```

#### 3. Provider (Dependencies)
Use for repository and service instances:
```dart
// Example: Repository Provider (see lib/repos/gatepass_repo.dart)
final gatepassRepoProvider = Provider<GatepassRepo>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return GatepassRepo(apiClient);
});
```

#### 4. StreamProvider (Real-time Data)
Use for streams like connectivity:
```dart
// Example: Connectivity Provider (see lib/presentation/features/connectivity/providers/connectivity_provider.dart)
final connectivityStatusProvider = StreamProvider<ConnectivityStatus>((ref) {
  final connectivityService = ref.watch(connectivityServiceProvider);
  return connectivityService.connectivityStream;
});
```

### Consuming Providers in UI

#### Using AsyncNotifier State
```dart
class FeatureScreen extends ConsumerStatefulWidget {
  const FeatureScreen({super.key});

  @override
  ConsumerState<FeatureScreen> createState() => _FeatureScreenState();
}

class _FeatureScreenState extends ConsumerState<FeatureScreen> {
  @override
  void initState() {
    super.initState();
    // Load data on screen init
    Future.microtask(
      () => ref.read(featureProvider.notifier).performAction(),
    );
  }

  @override
  Widget build(BuildContext context) {
    // Watch the provider
    final featureState = ref.watch(featureProvider);

    return featureState.when(
      data: (state) {
        if (state.isLoading) {
          return const CircularProgressIndicator();
        }
        if (state.error != null) {
          return Text('Error: ${state.error}');
        }
        return YourContent(data: state.data);
      },
      loading: () => const CircularProgressIndicator(),
      error: (error, stack) => Text('Error: $error'),
    );
  }
}
```

#### Listening to State Changes
```dart
// Listen for side effects (dialogs, navigation)
ref.listen<AsyncValue<FeatureState>>(featureProvider, (previous, next) {
  next.whenData((state) {
    if (state.error != null) {
      CustomSnackbar.showError(context, state.error!);
    }
    if (state.isSuccess) {
      CustomDialog.showSuccess(context, message: 'Action completed!');
    }
  });
});
```

## 🌐 Network Layer (ApiClient Pattern)

### ApiState Sealed Class
The project uses a custom sealed class for API responses:
```dart
sealed class ApiState<T> {
  const ApiState();
}

class ApiInitial<T> extends ApiState<T> {
  const ApiInitial();
}

class ApiLoading<T> extends ApiState<T> {
  final double? progress;
  const ApiLoading({this.progress});
}

class ApiSuccess<T> extends ApiState<T> {
  final T data;
  final int? statusCode;
  const ApiSuccess(this.data, {this.statusCode});
}

class ApiError<T> extends ApiState<T> {
  final String message;
  final int? statusCode;
  final dynamic error;
  final ApiErrorType type;
  
  const ApiError({
    required this.message,
    this.statusCode,
    this.error,
    required this.type,
  });
}

enum ApiErrorType {
  noInternet,
  timeout,
  serverError,
  unauthorized,
  notFound,
  badRequest,
  unknown,
}
```

### Repository Pattern
All API calls must go through repository classes:
```dart
class FeatureRepo {
  final ApiClient _apiClient;

  FeatureRepo(this._apiClient);

  Future<ApiState<DataModel>> fetchData() async {
    return _apiClient.get<DataModel>(
      '/endpoint',
      parser: (data) => DataModel.fromJson(data as Map<String, dynamic>),
    );
  }

  Future<ApiState<ResponseModel>> postData({
    required String param1,
    required String param2,
  }) async {
    final requestData = {
      "param1": param1,
      "param2": param2,
    };

    return _apiClient.post<ResponseModel>(
      '/endpoint',
      data: requestData,
      parser: (data) => ResponseModel.fromJson(data as Map<String, dynamic>),
    );
  }
}

// Provider for repository
final featureRepoProvider = Provider<FeatureRepo>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return FeatureRepo(apiClient);
});
```

### Handling API Responses
```dart
final result = await repo.fetchData();

if (result is ApiSuccess<DataModel>) {
  // Handle success
  final data = result.data;
  final statusCode = result.statusCode;
} else if (result is ApiError<DataModel>) {
  // Handle error
  final message = result.message;
  final statusCode = result.statusCode;
  final errorType = result.type;
  
  if (errorType == ApiErrorType.noInternet) {
    // Handle no internet
  } else if (errorType == ApiErrorType.unauthorized) {
    // Handle unauthorized
  }
}
```

## 🎨 UI Components & Theming

### Color System
Use the predefined color constants from `app_colors.dart`:
```dart
// Primary colors
AppColors.kPrimaryColor
AppColors.kPrimaryLightColor
AppColors.kPrimaryDarkColor

// Status colors
AppColors.kSuccessColor
AppColors.kErrorColor
AppColors.kWarningColor
AppColors.kInfoColor

// Text colors
AppColors.kTextPrimaryColor
AppColors.kTextSecondaryColor
AppColors.kTextTertiaryColor

// Gradients
AppColors.kPrimaryGradient
AppColors.kSecondaryGradient
```

### Theme System
The app uses Material 3 with centralized theming in `app_themes.dart`:
```dart
// Access theme colors
Theme.of(context).colorScheme.primary
Theme.of(context).colorScheme.surface
Theme.of(context).colorScheme.error

// Access text theme
Theme.of(context).textTheme.displayLarge
Theme.of(context).textTheme.headlineMedium
Theme.of(context).textTheme.bodyLarge

// Check dark mode
final isDarkMode = Theme.of(context).brightness == Brightness.dark;
```

### Reusable Custom Widgets

#### CustomScaffold
Use for all screens to maintain consistency:
```dart
CustomScaffold(
  appBar: AppBar(title: const Text('Screen Title')),
  body: YourContent(),
  showBackButton: true,  // Shows back button if needed
  padding: const EdgeInsets.all(20),  // Optional padding
  enableScroll: true,  // Enable scrolling if needed
)
```

#### CustomButton
Primary button with gradient support:
```dart
CustomButton(
  text: 'Submit',
  onPressed: () => handleSubmit(),
  isLoading: isLoading,
  isDisabled: !isValid,
  icon: const Icon(Iconsax.send),
  useGradient: true,  // Use gradient background
  width: double.infinity,
)

// Outlined variant
CustomOutlinedButton(
  text: 'Cancel',
  onPressed: () => context.pop(),
  icon: const Icon(Iconsax.close_circle),
)
```

#### CustomTextField
Consistent text field styling:
```dart
CustomTextField(
  controller: emailController,
  labelText: 'Email Address',
  hintText: 'Enter your email',
  prefixIcon: const Icon(Iconsax.sms),
  keyboardType: TextInputType.emailAddress,
  validator: (value) => validateEmail(value),
  onChanged: (value) => handleEmailChange(value),
)

// Password field with toggle
CustomTextField(
  controller: passwordController,
  labelText: 'Password',
  obscureText: true,
  showPasswordToggle: true,
  prefixIcon: const Icon(Iconsax.lock),
  validator: (value) => validatePassword(value),
)
```

#### CustomDropdown
Dropdown matching CustomTextField style:
```dart
CustomDropdown<ActionType>(
  value: selectedActionType,
  labelText: 'Select Action Type',
  hintText: 'Choose an action',
  prefixIcon: const Icon(Iconsax.setting_2),
  items: actionTypes.map((actionType) {
    return DropdownMenuItem<ActionType>(
      value: actionType,
      child: Text(actionType.displayName),
    );
  }).toList(),
  onChanged: (ActionType? newValue) {
    if (newValue != null) {
      ref.read(actionTypeProvider.notifier).setActionType(newValue);
    }
  },
)
```

### Dialogs and Snackbars

#### CustomDialog Utilities
```dart
// Info dialog
CustomDialog.showInfoDialog(
  context,
  title: 'Information',
  message: 'Your action was successful',
);

// Error dialog with retry
CustomDialog.showErrorDialog(
  context,
  title: 'Error Occurred',
  message: 'Failed to load data',
);

// Input dialog
final result = await CustomDialog.showInputDialog(
  context,
  title: 'Enter Pass Number',
  hintText: 'Pass Number',
  prefixIcon: const Icon(Iconsax.barcode),
  keyboardType: TextInputType.text,
);

// Success dialog with navigation
CustomDialog.showSuccessDialog(
  context,
  title: 'Success',
  message: 'Gate pass verified successfully',
  buttonText: 'Go to Dashboard',
  onButtonPressed: () {
    context.go(kDashboardRoute);
  },
);
```

#### CustomSnackbar Utilities
```dart
// Success snackbar
CustomSnackbar.showSuccess(context, 'Operation completed successfully');

// Error snackbar
CustomSnackbar.showError(context, 'Failed to process request');

// Info snackbar
CustomSnackbar.showInfo(context, 'Please check your internet connection');

// Warning snackbar
CustomSnackbar.showWarning(context, 'This action cannot be undone');

// Normal snackbar
CustomSnackbar.showNormal(context, 'Feature coming soon!');
```

## 🧭 Navigation (GoRouter)

### Route Definition
Routes are defined in `core/router/app_routes.dart` as constants:
```dart
// Route paths
const String kSigninRoute = '/';
const String kDashboardRoute = '/dashboard';
const String kScanGatepassRoute = '/scan-gatepass';

// Route names
const String kSigninRouteName = 'signin';
const String kDashboardRouteName = 'dashboard';
```

### GoRouter Configuration
Router is configured in `core/router/app_router.dart`:
```dart
final goRouterProvider = Provider<GoRouter>((ref) {
  return GoRouter(
    initialLocation: kSigninRoute,
    debugLogDiagnostics: true,
    navigatorKey: navigatorKey,
    routes: [
      GoRoute(
        path: kDashboardRoute,
        name: kDashboardRouteName,
        pageBuilder: (context, state) {
          return MaterialPage(
            key: state.pageKey,
            child: const DashboardScreen(),
          );
        },
      ),
      // Passing data through extra
      GoRoute(
        path: kGatePassDetailsRoute,
        name: kGatePassDetailsRouteName,
        pageBuilder: (context, state) {
          final passNumber = state.extra as String;
          return MaterialPage(
            key: state.pageKey,
            child: GatePassDetailsScreen(passNumber: passNumber),
          );
        },
      ),
    ],
  );
});
```

### Navigation Usage
```dart
// Navigate to route
context.go(kDashboardRoute);

// Navigate with data
context.push(kGatePassDetailsRoute, extra: passNumber);

// Navigate with named route
context.goNamed(kDashboardRouteName);

// Pop current route
context.pop();

// Replace current route
context.replace(kSigninRoute);
```

## 🔌 Connectivity Monitoring

### ConnectivityWrapper Pattern
The app uses an overlay-based connectivity monitoring system:
```dart
// In app.dart
MaterialApp.router(
  builder: (context, child) {
    return ConnectivityWrapper(child: child);
  },
)
```

The ConnectivityWrapper maintains widget state while showing/hiding the offline screen:
```dart
class ConnectivityWrapper extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final connectivityStatus = ref.watch(connectivityStatusProvider);

    return connectivityStatus.when(
      data: (status) {
        return Stack(
          children: [
            if (child != null) child!,  // Preserve state
            if (status == ConnectivityStatus.disconnected)
              Positioned.fill(child: const NoInternetScreen()),
          ],
        );
      },
      loading: () => const LoadingScreen(),
      error: (error, _) => ErrorScreen(error: error),
    );
  }
}
```

### Connectivity Service
Real-time network monitoring with internet reachability check:
```dart
class ConnectivityService {
  Stream<ConnectivityStatus> get connectivityStream async* {
    // Check initial connectivity
    final initialResult = await _connectivity.checkConnectivity();
    final initialStatus = await _checkConnectivityWithInternet(initialResult);
    yield initialStatus;

    // Listen to changes
    await for (final result in _connectivity.onConnectivityChanged) {
      final status = await _checkConnectivityWithInternet(result);
      if (status != lastStatus) {
        yield status;
      }
    }
  }

  Future<ConnectivityStatus> _checkConnectivityWithInternet(
    List<ConnectivityResult> result,
  ) async {
    if (result.contains(ConnectivityResult.none)) {
      return ConnectivityStatus.disconnected;
    }

    try {
      final response = await InternetAddress.lookup('google.com')
          .timeout(const Duration(seconds: 5));
      
      if (response.isNotEmpty && response[0].rawAddress.isNotEmpty) {
        return ConnectivityStatus.connected;
      }
    } catch (e) {
      return ConnectivityStatus.disconnected;
    }

    return ConnectivityStatus.disconnected;
  }
}
```

## 📦 Data Models

### Model Pattern
All models must include:
1. Immutable fields
2. `fromJson` factory constructor
3. `toJson` method
4. `copyWith` method (if mutable state needed)

```dart
class GatePass {
  final String id;
  final String passNumber;
  final String memberName;
  final DateTime createdAt;
  final List<Item> items;

  const GatePass({
    required this.id,
    required this.passNumber,
    required this.memberName,
    required this.createdAt,
    required this.items,
  });

  factory GatePass.fromJson(Map<String, dynamic> json) {
    return GatePass(
      id: json['_id'] as String,
      passNumber: json['passNumber'] as String,
      memberName: json['memberName'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      items: (json['items'] as List<dynamic>)
          .map((item) => Item.fromJson(item as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      '_id': id,
      'passNumber': passNumber,
      'memberName': memberName,
      'createdAt': createdAt.toIso8601String(),
      'items': items.map((item) => item.toJson()).toList(),
    };
  }

  GatePass copyWith({
    String? id,
    String? passNumber,
    String? memberName,
    DateTime? createdAt,
    List<Item>? items,
  }) {
    return GatePass(
      id: id ?? this.id,
      passNumber: passNumber ?? this.passNumber,
      memberName: memberName ?? this.memberName,
      createdAt: createdAt ?? this.createdAt,
      items: items ?? this.items,
    );
  }
}
```

## 🔧 Extensions

### SizedBox Extension
Use for consistent spacing:
```dart
// Vertical spacing
12.heightBox  // SizedBox(height: 12)
24.heightBox  // SizedBox(height: 24)

// Horizontal spacing
8.widthBox   // SizedBox(width: 8)
16.widthBox  // SizedBox(width: 16)
```

### DateTime Extension
Use for date formatting:
```dart
final date = DateTime.now();

date.formatDate()      // "Oct 16, 2025"
date.formatTime()      // "2:30 PM"
date.formatDateTime()  // "Oct 16, 2025 at 2:30 PM"
date.toFormattedString() // "2025-10-16"
```

## 🎯 Code Style Guidelines

### Naming Conventions
```dart
// Constants with k prefix (from app_colors.dart pattern)
const Color kPrimaryColor = Color(0xFF2563EB);
const String kApiBaseUrl = 'https://api.example.com';
const Duration kAnimationDuration = Duration(milliseconds: 300);

// Route constants with k prefix
const String kDashboardRoute = '/dashboard';
const String kDashboardRouteName = 'dashboard';

// Private members with underscore
final _apiClient = ApiClient();
void _handleSubmit() {}

// Provider naming
final featureProvider = AsyncNotifierProvider<FeatureNotifier, FeatureState>(...);
final featureRepoProvider = Provider<FeatureRepo>(...);
final featureServiceProvider = Provider<FeatureService>(...);
```

### File Organization
```dart
// 1. Imports (organized by type)
import 'dart:async';                        // Dart SDK
import 'package:flutter/material.dart';     // Flutter framework
import 'package:flutter_riverpod/flutter_riverpod.dart';  // Third-party
import 'package:pcq_fir_pilot_app/core/...';  // Project imports

// 2. Class/Widget definition
class FeatureScreen extends ConsumerStatefulWidget {
  const FeatureScreen({super.key});

  @override
  ConsumerState<FeatureScreen> createState() => _FeatureScreenState();
}

// 3. State class
class _FeatureScreenState extends ConsumerState<FeatureScreen> {
  // 3.1 State variables
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _controller;

  // 3.2 Lifecycle methods
  @override
  void initState() {
    super.initState();
    _controller = TextEditingController();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  // 3.3 Build method
  @override
  Widget build(BuildContext context) {
    return CustomScaffold(...);
  }

  // 3.4 Private helper methods
  void _handleSubmit() {
    // ...
  }

  Widget _buildSection() {
    // ...
  }
}

// 4. Provider definitions (at file end)
final featureProvider = AsyncNotifierProvider<FeatureNotifier, FeatureState>(
  () => FeatureNotifier(),
);
```

### Widget Composition
Break down large build methods into smaller private widgets:
```dart
// ❌ Avoid large build methods
@override
Widget build(BuildContext context) {
  return Column(
    children: [
      // 100+ lines of widget code
    ],
  );
}

// ✅ Break into private widget classes
@override
Widget build(BuildContext context) {
  return Column(
    children: [
      _HeaderSection(data: state.data),
      16.heightBox,
      _ContentSection(items: state.items),
      16.heightBox,
      _FooterActions(onSubmit: _handleSubmit),
    ],
  );
}

// Private widget class
class _HeaderSection extends StatelessWidget {
  final Data data;

  const _HeaderSection({required this.data});

  @override
  Widget build(BuildContext context) {
    return Container(...);
  }
}
```

## � Common Patterns and Best Practices

### Loading States
Always show loading indicators during async operations:
```dart
if (state.isLoading) {
  return const Center(
    child: CircularProgressIndicator(),
  );
}

// Or with custom loading widget
if (state.isLoading) {
  return const CustomLoadingWidget();
}
```

### Error Handling
Display user-friendly error messages:
```dart
if (state.error != null) {
  return Center(
    child: Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        const Icon(
          Iconsax.warning_2,
          size: 64,
          color: AppColors.kErrorColor,
        ),
        16.heightBox,
        Text(
          state.error!,
          style: const TextStyle(
            fontSize: 16,
            color: AppColors.kTextSecondaryColor,
          ),
          textAlign: TextAlign.center,
        ),
        24.heightBox,
        CustomButton(
          text: 'Try Again',
          onPressed: () => ref.read(featureProvider.notifier).retry(),
          icon: const Icon(Iconsax.refresh),
        ),
      ],
    ),
  );
}
```

### Form Validation
Use GlobalKey for form validation:
```dart
class _FormScreenState extends ConsumerState<FormScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _handleSubmit() {
    if (_formKey.currentState!.validate()) {
      ref.read(authProvider.notifier).signIn(
        email: _emailController.text,
        password: _passwordController.text,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Form(
      key: _formKey,
      child: Column(
        children: [
          CustomTextField(
            controller: _emailController,
            labelText: 'Email',
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Email is required';
              }
              if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(value)) {
                return 'Enter a valid email';
              }
              return null;
            },
          ),
          16.heightBox,
          CustomTextField(
            controller: _passwordController,
            labelText: 'Password',
            obscureText: true,
            showPasswordToggle: true,
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'Password is required';
              }
              if (value.length < 6) {
                return 'Password must be at least 6 characters';
              }
              return null;
            },
          ),
          24.heightBox,
          CustomButton(
            text: 'Sign In',
            onPressed: _handleSubmit,
            width: double.infinity,
          ),
        ],
      ),
    );
  }
}
```

### List Building
Use ListView.builder for large lists:
```dart
ListView.builder(
  itemCount: items.length,
  padding: const EdgeInsets.all(16),
  itemBuilder: (context, index) {
    final item = items[index];
    return ItemCard(item: item);
  },
)

// With separators
ListView.separated(
  itemCount: items.length,
  separatorBuilder: (context, index) => 12.heightBox,
  itemBuilder: (context, index) {
    return ItemCard(item: items[index]);
  },
)
```

### Responsive Design
Use MediaQuery for responsive layouts:
```dart
final screenWidth = MediaQuery.of(context).size.width;
final screenHeight = MediaQuery.of(context).size.height;
final isSmallScreen = screenWidth < 600;

// Responsive padding
final padding = isSmallScreen ? 16.0 : 24.0;

// Responsive font size
final fontSize = isSmallScreen ? 14.0 : 16.0;

// Use LayoutBuilder for complex responsive layouts
LayoutBuilder(
  builder: (context, constraints) {
    if (constraints.maxWidth > 600) {
      return WideLayout();
    }
    return NarrowLayout();
  },
)
```

### Conditional Rendering
Use if statements in collections:
```dart
Column(
  children: [
    const HeaderWidget(),
    if (showContent) 
      const ContentWidget(),
    if (user != null) 
      UserInfoWidget(user: user),
    if (items.isNotEmpty) ...[
      16.heightBox,
      ItemsList(items: items),
    ],
    const FooterWidget(),
  ],
)
```

### Safe Area and Padding
Use SafeArea for notch/status bar handling:
```dart
// CustomScaffold already handles this
CustomScaffold(
  safeAreaTop: true,
  safeAreaBottom: true,
  body: YourContent(),
)

// Manual SafeArea
SafeArea(
  top: true,
  bottom: true,
  child: YourWidget(),
)
```

## 📱 Specific Feature Patterns

### Dashboard Analytics
When implementing analytics features:
```dart
// Use FL Chart for data visualization
LineChart(
  LineChartData(
    lineBarsData: [
      LineChartBarData(
        spots: dataPoints,
        isCurved: true,
        color: AppColors.kPrimaryColor,
        barWidth: 3,
        dotData: const FlDotData(show: false),
        belowBarData: BarAreaData(
          show: true,
          color: AppColors.kPrimaryColor.withValues(alpha: 0.1),
        ),
      ),
    ],
  ),
)

// Use CompactStatCard for metrics display
CompactStatCard(
  title: 'Total Gate Passes',
  value: '${analytics.totalPasses}',
  subtitle: 'This month',
  icon: Iconsax.document,
  color: AppColors.kPrimaryColor,
)
```

### QR Code Scanning Flow
Follow the established scanning pattern:
```dart
// 1. Show input dialog
final passNumber = await CustomDialog.showInputDialog(
  context,
  title: 'Enter Pass Number',
  hintText: 'Scan or enter manually',
  prefixIcon: const Icon(Iconsax.barcode),
);

if (passNumber != null && mounted) {
  // 2. Fetch details
  await ref.read(gatePassDetailsProvider.notifier)
    .fetchGatePassDetails(passNumber);
  
  // 3. Navigate to details
  if (mounted) {
    context.push(kGatePassDetailsRoute, extra: passNumber);
  }
}
```

### Item Verification Workflow
Follow the multi-step verification pattern:
```dart
// Step 1: Scan gate pass -> GatePassDetailsScreen
// Step 2: View items -> GatePassScanItemsScreen
// Step 3: Scan individual items -> ItemVerificationScreen
// Step 4: Verify items -> Update status
// Step 5: Complete verification -> GatePassVerificationScreen

// Always update the scanned items list
ref.read(gatePassScanItemProvider.notifier).updateScannedItem(
  verifiedItem,
  originalItemId,
);
```

### Member Authentication
Follow the auth flow pattern:
```dart
// 1. Validate credentials
if (!_formKey.currentState!.validate()) return;

// 2. Show loading
ref.read(signInProvider.notifier).signIn(
  email: email,
  password: password,
);

// 3. Listen for state changes
ref.listen<AsyncValue<SignInState>>(signInProvider, (previous, next) {
  next.whenData((state) {
    if (state.isAuthenticated) {
      // Navigate to dashboard
      context.go(kDashboardRoute);
    } else if (state.error != null) {
      // Show error
      CustomSnackbar.showError(context, state.error!);
    }
  });
});
```

## 🔒 Security Best Practices

### Token Management
```dart
// Store tokens securely using SharedPreferences
final sharedPreferences = ref.read(sharedPreferencesProvider);
await sharedPreferences.setString('auth_token', token);

// Read tokens
final token = sharedPreferences.getString('auth_token');

// Clear on logout
await sharedPreferences.clearAll();
```

### API Security
```dart
// Never hardcode API keys in code
// Use environment variables or secure storage
const apiKey = String.fromEnvironment('API_KEY');

// Always use HTTPS
const apiBaseUrl = 'https://api.example.com';

// Include authentication headers
final headers = {
  'Authorization': 'Bearer $token',
  'Content-Type': 'application/json',
};
```

## 🐛 Debugging Patterns

### Debug Logging
```dart
import 'package:flutter/foundation.dart';

// Use kDebugMode for debug prints
if (kDebugMode) {
  print('🔍 Debug info: $data');
}

// Use dev.log for structured logging
import 'dart:developer' as dev;

dev.log(
  'API Response',
  name: 'network',
  error: error,
  stackTrace: stackTrace,
);
```

### Error Boundaries
```dart
// Wrap error-prone widgets with error handling
try {
  return YourWidget(data: data);
} catch (e) {
  if (kDebugMode) {
    print('Error rendering widget: $e');
  }
  return ErrorWidget(error: e.toString());
}
```

## 📊 Performance Optimization

### Widget Optimization
```dart
// 1. Use const constructors wherever possible
const Text('Hello');
const SizedBox(height: 16);
const Icon(Iconsax.home);

// 2. Extract static widgets
static const _staticWidget = Text('Static content');

// 3. Use keys for list items
ListView.builder(
  itemBuilder: (context, index) {
    return ItemWidget(
      key: ValueKey(items[index].id),
      item: items[index],
    );
  },
)

// 4. Avoid rebuilding unnecessary widgets
class MyWidget extends StatelessWidget {
  const MyWidget({super.key});

  @override
  Widget build(BuildContext context) {
    // Only watch specific values, not entire state
    final isLoading = ref.watch(
      featureProvider.select((state) => state.value?.isLoading ?? false),
    );
    
    return YourContent(isLoading: isLoading);
  }
}
```

### Memory Management
```dart
// Always dispose controllers
@override
void dispose() {
  _emailController.dispose();
  _passwordController.dispose();
  _scrollController.dispose();
  _animationController.dispose();
  super.dispose();
}

// Use cached network images
CachedNetworkImage(
  imageUrl: imageUrl,
  placeholder: (context, url) => const CircularProgressIndicator(),
  errorWidget: (context, url, error) => const Icon(Icons.error),
  memCacheWidth: 500,  // Limit cache size
)
```

## 🔄 Migration and Updates

### When Adding New Features
1. Create feature folder in `presentation/features/`
2. Follow the established structure: `models/`, `providers/`, `view/`
3. Create AsyncNotifier provider following the pattern
4. Add repository in `repos/` if API calls needed
5. Update router in `core/router/app_router.dart`
6. Add route constants in `core/router/app_routes.dart`
7. Use existing custom widgets for consistency

### When Modifying Existing Features
1. Check existing providers before creating new ones
2. Maintain backward compatibility with existing state
3. Update related models if data structure changes
4. Test connectivity handling with offline scenarios
5. Verify theme support (light/dark modes)

## 📚 Reference Examples

### Complete Feature Implementation
See these files for reference:
- **Dashboard**: `lib/presentation/features/dashboard/`
  - Shows analytics with charts
  - Action type selection
  - Pull-to-refresh pattern
  
- **Gate Pass Details**: `lib/presentation/features/gatepass/`
  - Multi-step workflow
  - Item scanning and verification
  - Real-time status updates
  
- **Authentication**: `lib/presentation/features/auth/`
  - Form validation
  - Token storage
  - Auto-login check

### Custom Widget Examples
- **CustomScaffold**: `lib/presentation/widgets/custom_scaffold.dart`
- **CustomButton**: `lib/presentation/widgets/custom_button_widget.dart`
- **CustomTextField**: `lib/presentation/widgets/custom_text_field.dart`
- **CustomDropdown**: `lib/presentation/widgets/custom_dropdown.dart`

### Provider Examples
- **AsyncNotifier**: `lib/presentation/features/dashboard/providers/dashboard_provider.dart`
- **Notifier**: `lib/presentation/features/dashboard/providers/action_type_provider.dart`
- **StreamProvider**: `lib/presentation/features/connectivity/providers/connectivity_provider.dart`

## 🎓 Project-Specific Rules

### MUST Follow
1. ✅ All providers MUST use AsyncNotifier pattern
2. ✅ All API calls MUST go through repository layer
3. ✅ All screens MUST use CustomScaffold
4. ✅ All colors MUST come from AppColors constants
5. ✅ All routes MUST be defined in app_routes.dart
6. ✅ All spacing MUST use SizedBox extensions (.heightBox, .widthBox)
7. ✅ All dialogs MUST use CustomDialog utilities
8. ✅ All snackbars MUST use CustomSnackbar utilities
9. ✅ All text fields MUST use CustomTextField
10. ✅ All buttons MUST use CustomButton or CustomOutlinedButton

### AVOID
1. ❌ Don't use StatelessWidget for providers (use ConsumerWidget)
2. ❌ Don't use StatefulWidget for providers (use ConsumerStatefulWidget)
3. ❌ Don't call APIs directly from UI (use repositories)
4. ❌ Don't hardcode colors (use AppColors)
5. ❌ Don't hardcode strings for routes (use route constants)
6. ❌ Don't use print() (use kDebugMode check with print or dev.log)
7. ❌ Don't ignore connectivity status (UI should handle offline state)
8. ❌ Don't create duplicate providers (check existing ones first)
9. ❌ Don't bypass CustomDialog/CustomSnackbar utilities
10. ❌ Don't forget to dispose controllers and listeners

### Code Review Checklist
Before committing code, verify:
- [ ] Follows AsyncNotifier pattern
- [ ] Uses existing custom widgets
- [ ] Handles loading/error states
- [ ] Includes proper error handling
- [ ] Disposes resources properly
- [ ] Uses theme colors (not hardcoded)
- [ ] Includes documentation comments
- [ ] Follows file organization pattern
- [ ] Uses consistent naming (k prefix for constants)
- [ ] Tests offline scenarios
- [ ] Supports dark mode
- [ ] Uses appropriate spacing (.heightBox/.widthBox)

## Flutter style guide

## Flutter style guide

## Package Management
* **Pub Tool:** To manage packages, use the `pub` tool, if available.
* **External Packages:** If a new feature requires an external package, use the
  `pub_dev_search` tool, if it is available. Otherwise, identify the most
  suitable and stable package from pub.dev.
* **Adding Dependencies:** To add a regular dependency, use the `pub` tool, if
  it is available. Otherwise, run `flutter pub add <package_name>`.
* **Adding Dev Dependencies:** To add a development dependency, use the `pub`
  tool, if it is available, with `dev:<package name>`. Otherwise, run `flutter
  pub add dev:<package_name>`.
* **Dependency Overrides:** To add a dependency override, use the `pub` tool, if
  it is available, with `override:<package name>:1.0.0`. Otherwise, run `flutter
  pub add override:<package_name>:1.0.0`.
* **Removing Dependencies:** To remove a dependency, use the `pub` tool, if it
  is available. Otherwise, run `dart pub remove <package_name>`.

## Code Quality
* **Code structure:** Adhere to maintainable code structure and separation of
  concerns (e.g., UI logic separate from business logic).
* **Naming conventions:** Avoid abbreviations and use meaningful, consistent,
  descriptive names for variables, functions, and classes.
* **Conciseness:** Write code that is as short as it can be while remaining
  clear.
* **Simplicity:** Write straightforward code. Code that is clever or
  obscure is difficult to maintain.
* **Error Handling:** Anticipate and handle potential errors. Don't let your
  code fail silently.
* **Styling:**
    * Line length: Lines should be 80 characters or fewer.
    * Use `PascalCase` for classes, `camelCase` for
      members/variables/functions/enums, and `snake_case` for files.
* **Functions:**
    * Functions short and with a single purpose (strive for less than 20 lines).
* **Testing:** Write code with testing in mind. Use the `file`, `process`, and
  `platform` packages, if appropriate, so you can inject in-memory and fake
  versions of the objects.
* **Logging:** Use the `logging` package instead of `print`.

## Dart Best Practices
* **Effective Dart:** Follow the official Effective Dart guidelines
  (https://dart.dev/effective-dart)
* **Class Organization:** Define related classes within the same library file.
  For large libraries, export smaller, private libraries from a single top-level
  library.
* **Library Organization:** Group related libraries in the same folder.
* **API Documentation:** Add documentation comments to all public APIs,
  including classes, constructors, methods, and top-level functions.
* **Comments:** Write clear comments for complex or non-obvious code. Avoid
  over-commenting.
* **Trailing Comments:** Don't add trailing comments.
* **Async/Await:** Ensure proper use of `async`/`await` for asynchronous
  operations with robust error handling.
    * Use `Future`s, `async`, and `await` for asynchronous operations.
    * Use `Stream`s for sequences of asynchronous events.
* **Null Safety:** Write code that is soundly null-safe. Leverage Dart's null
  safety features. Avoid `!` unless the value is guaranteed to be non-null.
* **Pattern Matching:** Use pattern matching features where they simplify the
  code.
* **Records:** Use records to return multiple types in situations where defining
  an entire class is cumbersome.
* **Switch Statements:** Prefer using exhaustive `switch` statements or
  expressions, which don't require `break` statements.
* **Exception Handling:** Use `try-catch` blocks for handling exceptions, and
  use exceptions appropriate for the type of exception. Use custom exceptions
  for situations specific to your code.
* **Arrow Functions:** Use arrow syntax for simple one-line functions.

## Flutter Best Practices
* **Immutability:** Widgets (especially `StatelessWidget`) are immutable; when
  the UI needs to change, Flutter rebuilds the widget tree.
* **Composition:** Prefer composing smaller widgets over extending existing
  ones. Use this to avoid deep widget nesting.
* **Private Widgets:** Use small, private `Widget` classes instead of private
  helper methods that return a `Widget`.
* **Build Methods:** Break down large `build()` methods into smaller, reusable
  private Widget classes.
* **List Performance:** Use `ListView.builder` or `SliverList` for long lists to
  create lazy-loaded lists for performance.
* **Isolates:** Use `compute()` to run expensive calculations in a separate
  isolate to avoid blocking the UI thread, such as JSON parsing.
* **Const Constructors:** Use `const` constructors for widgets and in `build()`
  methods whenever possible to reduce rebuilds.
* **Build Method Performance:** Avoid performing expensive operations, like
  network calls or complex computations, directly within `build()` methods.

## API Design Principles
When building reusable APIs, such as a library, follow these principles.

* **Consider the User:** Design APIs from the perspective of the person who will
  be using them. The API should be intuitive and easy to use correctly.
* **Documentation is Essential:** Good documentation is a part of good API
  design. It should be clear, concise, and provide examples.

## Application Architecture
* **Separation of Concerns:** Aim for separation of concerns similar to MVC/MVVM, with defined Model,
  View, and ViewModel/Controller roles.
* **Logical Layers:** Organize the project into logical layers:
    * Presentation (widgets, screens)
    * Domain (business logic classes)
    * Data (model classes, API clients)
    * Core (shared classes, utilities, and extension types)
* **Feature-based Organization:** For larger projects, organize code by feature,
  where each feature has its own presentation, domain, and data subfolders. This
  improves navigability and scalability.

## Lint Rules

Include the package in the `analysis_options.yaml` file. Use the following
analysis_options.yaml file as a starting point:

```yaml
include: package:flutter_lints/flutter.yaml

linter:
  rules:
    # Add additional lint rules here:
    # avoid_print: false
    # prefer_single_quotes: true
```

### State Management
* **Built-in Solutions:** Prefer Flutter's built-in state management solutions.
  Do not use a third-party package unless explicitly requested.
* **Streams:** Use `Streams` and `StreamBuilder` for handling a sequence of
  asynchronous events.
* **Futures:** Use `Futures` and `FutureBuilder` for handling a single
  asynchronous operation that will complete in the future.
* **ValueNotifier:** Use `ValueNotifier` with `ValueListenableBuilder` for
  simple, local state that involves a single value.

  ```dart
  // Define a ValueNotifier to hold the state.
  final ValueNotifier<int> _counter = ValueNotifier<int>(0);

  // Use ValueListenableBuilder to listen and rebuild.
  ValueListenableBuilder<int>(
    valueListenable: _counter,
    builder: (context, value, child) {
      return Text('Count: $value');
    },
  );
    ```

* **ChangeNotifier:** For state that is more complex or shared across multiple
  widgets, use `ChangeNotifier`.
* **ListenableBuilder:** Use `ListenableBuilder` to listen to changes from a
  `ChangeNotifier` or other `Listenable`.
* **MVVM:** When a more robust solution is needed, structure the app using the
  Model-View-ViewModel (MVVM) pattern.
* **Dependency Injection:** Use simple manual constructor dependency injection
  to make a class's dependencies explicit in its API, and to manage dependencies
  between different layers of the application.
* **Provider:** If a dependency injection solution beyond manual constructor
  injection is explicitly requested, `provider` can be used to make services,
  repositories, or complex state objects available to the UI layer without tight
  coupling (note: this document generally defaults against third-party packages
  for state management unless explicitly requested).

### Data Flow
* **Data Structures:** Define data structures (classes) to represent the data
  used in the application.
* **Data Abstraction:** Abstract data sources (e.g., API calls, database
  operations) using Repositories/Services to promote testability.

### Routing
* **GoRouter:** Use the `go_router` package for declarative navigation, deep
  linking, and web support.
* **GoRouter Setup:** To use `go_router`, first add it to your `pubspec.yaml`
  using the `pub` tool's `add` command.

  ```dart
  // 1. Add the dependency
  // flutter pub add go_router

  // 2. Configure the router
  final GoRouter _router = GoRouter(
    routes: <RouteBase>[
      GoRoute(
        path: '/',
        builder: (context, state) => const HomeScreen(),
        routes: <RouteBase>[
          GoRoute(
            path: 'details/:id', // Route with a path parameter
            builder: (context, state) {
              final String id = state.pathParameters['id']!;
              return DetailScreen(id: id);
            },
          ),
        ],
      ),
    ],
  );

  // 3. Use it in your MaterialApp
  MaterialApp.router(
    routerConfig: _router,
  );
  ```
* **Authentication Redirects:** Configure `go_router`'s `redirect` property to
  handle authentication flows, ensuring users are redirected to the login screen
  when unauthorized, and back to their intended destination after successful
  login.

* **Navigator:** Use the built-in `Navigator` for short-lived screens that do
  not need to be deep-linkable, such as dialogs or temporary views.

  ```dart
  // Push a new screen onto the stack
  Navigator.push(
    context,
    MaterialPageRoute(builder: (context) => const DetailsScreen()),
  );

  // Pop the current screen to go back
  Navigator.pop(context);
  ```

### Data Handling & Serialization
* **JSON Serialization:** Use `json_serializable` and `json_annotation` for
  parsing and encoding JSON data.
* **Field Renaming:** When encoding data, use `fieldRename: FieldRename.snake`
  to convert Dart's camelCase fields to snake_case JSON keys.

  ```dart
  // In your model file
  import 'package:json_annotation/json_annotation.dart';

  part 'user.g.dart';

  @JsonSerializable(fieldRename: FieldRename.snake)
  class User {
    final String firstName;
    final String lastName;

    User({required this.firstName, required this.lastName});

    factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
    Map<String, dynamic> toJson() => _$UserToJson(this);
  }
  ```


### Logging
* **Structured Logging:** Use the `log` function from `dart:developer` for
  structured logging that integrates with Dart DevTools.

  ```dart
  import 'dart:developer' as developer;

  // For simple messages
  developer.log('User logged in successfully.');

  // For structured error logging
  try {
    // ... code that might fail
  } catch (e, s) {
    developer.log(
      'Failed to fetch data',
      name: 'myapp.network',
      level: 1000, // SEVERE
      error: e,
      stackTrace: s,
    );
  }
  ```

## Code Generation
* **Build Runner:** If the project uses code generation, ensure that
  `build_runner` is listed as a dev dependency in `pubspec.yaml`.
* **Code Generation Tasks:** Use `build_runner` for all code generation tasks,
  such as for `json_serializable`.
* **Running Build Runner:** After modifying files that require code generation,
  run the build command:

  ```shell
  dart run build_runner build --delete-conflicting-outputs
  ```

## Testing
* **Running Tests:** To run tests, use the `run_tests` tool if it is available,
  otherwise use `flutter test`.
* **Unit Tests:** Use `package:test` for unit tests.
* **Widget Tests:** Use `package:flutter_test` for widget tests.
* **Integration Tests:** Use `package:integration_test` for integration tests.
* **Assertions:** Prefer using `package:checks` for more expressive and readable
  assertions over the default `matchers`.

### Testing Best practices
* **Convention:** Follow the Arrange-Act-Assert (or Given-When-Then) pattern.
* **Unit Tests:** Write unit tests for domain logic, data layer, and state
  management.
* **Widget Tests:** Write widget tests for UI components.
* **Integration Tests:** For broader application validation, use integration
  tests to verify end-to-end user flows.
* **integration_test package:** Use the `integration_test` package from the
  Flutter SDK for integration tests. Add it as a `dev_dependency` in
  `pubspec.yaml` by specifying `sdk: flutter`.
* **Mocks:** Prefer fakes or stubs over mocks. If mocks are absolutely
  necessary, use `mockito` or `mocktail` to create mocks for dependencies. While
  code generation is common for state management (e.g., with `freezed`), try to
  avoid it for mocks.
* **Coverage:** Aim for high test coverage.

## Visual Design & Theming
* **UI Design:** Build beautiful and intuitive user interfaces that follow
  modern design guidelines.
* **Responsiveness:** Ensure the app is mobile responsive and adapts to
  different screen sizes, working perfectly on mobile and web.
* **Navigation:** If there are multiple pages for the user to interact with,
  provide an intuitive and easy navigation bar or controls.
* **Typography:** Stress and emphasize font sizes to ease understanding, e.g.,
  hero text, section headlines, list headlines, keywords in paragraphs.
* **Background:** Apply subtle noise texture to the main background to add a
  premium, tactile feel.
* **Shadows:** Multi-layered drop shadows create a strong sense of depth; cards
  have a soft, deep shadow to look "lifted."
* **Icons:** Incorporate icons to enhance the user’s understanding and the
  logical navigation of the app.
* **Interactive Elements:** Buttons, checkboxes, sliders, lists, charts, graphs,
  and other interactive elements have a shadow with elegant use of color to
  create a "glow" effect.

### Theming
* **Centralized Theme:** Define a centralized `ThemeData` object to ensure a
  consistent application-wide style.
* **Light and Dark Themes:** Implement support for both light and dark themes,
  ideal for a user-facing theme toggle (`ThemeMode.light`, `ThemeMode.dark`,
  `ThemeMode.system`).
* **Color Scheme Generation:** Generate harmonious color palettes from a single
  color using `ColorScheme.fromSeed`.

  ```dart
  final ThemeData lightTheme = ThemeData(
    colorScheme: ColorScheme.fromSeed(
      seedColor: Colors.deepPurple,
      brightness: Brightness.light,
    ),
    // ... other theme properties
  );
  ```
* **Color Palette:** Include a wide range of color concentrations and hues in
  the palette to create a vibrant and energetic look and feel.
* **Component Themes:** Use specific theme properties (e.g., `appBarTheme`,
  `elevatedButtonTheme`) to customize the appearance of individual Material
  components.
* **Custom Fonts:** For custom fonts, use the `google_fonts` package. Define a
  `TextTheme` to apply fonts consistently.

  ```dart
  // 1. Add the dependency
  // flutter pub add google_fonts

  // 2. Define a TextTheme with a custom font
  final TextTheme appTextTheme = TextTheme(
    displayLarge: GoogleFonts.oswald(fontSize: 57, fontWeight: FontWeight.bold),
    titleLarge: GoogleFonts.roboto(fontSize: 22, fontWeight: FontWeight.w500),
    bodyMedium: GoogleFonts.openSans(fontSize: 14),
  );
  ```

### Assets and Images
* **Image Guidelines:** If images are needed, make them relevant and meaningful,
  with appropriate size, layout, and licensing (e.g., freely available). Provide
  placeholder images if real ones are not available.
* **Asset Declaration:** Declare all asset paths in your `pubspec.yaml` file.

    ```yaml
    flutter:
      uses-material-design: true
      assets:
        - assets/images/
    ```

* **Local Images:** Use `Image.asset` for local images from your asset
  bundle.

    ```dart
    Image.asset('assets/images/placeholder.png')
    ```
* **Network images:** Use NetworkImage for images loaded from the network.
* **Cached images:** For cached images, use NetworkImage a package like
  `cached_network_image`.
* **Custom Icons:** Use `ImageIcon` to display an icon from an `ImageProvider`,
  useful for custom icons not in the `Icons` class.
* **Network Images:** Use `Image.network` to display images from a URL, and
  always include `loadingBuilder` and `errorBuilder` for a better user
  experience.

    ```dart
    Image.network(
      'https://picsum.photos/200/300',
      loadingBuilder: (context, child, progress) {
        if (progress == null) return child;
        return const Center(child: CircularProgressIndicator());
      },
      errorBuilder: (context, error, stackTrace) {
        return const Icon(Icons.error);
      },
    )
    ```
## UI Theming and Styling Code

* **Responsiveness:** Use `LayoutBuilder` or `MediaQuery` to create responsive
  UIs.
* **Text:** Use `Theme.of(context).textTheme` for text styles.
* **Text Fields:** Configure `textCapitalization`, `keyboardType`, and
* **Responsiveness:** Use `LayoutBuilder` or `MediaQuery` to create responsive
  UIs.
* **Text:** Use `Theme.of(context).textTheme` for text styles.
  remote images.

```dart
// When using network images, always provide an errorBuilder.
Image.network(
  'https://example.com/image.png',
  errorBuilder: (context, error, stackTrace) {
    return const Icon(Icons.error); // Show an error icon
  },
);
```

## Material Theming Best Practices

### Embrace `ThemeData` and Material 3

* **Use `ColorScheme.fromSeed()`:** Use this to generate a complete, harmonious
  color palette for both light and dark modes from a single seed color.
* **Define Light and Dark Themes:** Provide both `theme` and `darkTheme` to your
  `MaterialApp` to support system brightness settings seamlessly.
* **Centralize Component Styles:** Customize specific component themes (e.g.,
  `elevatedButtonTheme`, `cardTheme`, `appBarTheme`) within `ThemeData` to
  ensure consistency.
* **Dark/Light Mode and Theme Toggle:** Implement support for both light and
  dark themes using `theme` and `darkTheme` properties of `MaterialApp`. The
  `themeMode` property can be dynamically controlled (e.g., via a
  `ChangeNotifierProvider`) to allow for toggling between `ThemeMode.light`,
  `ThemeMode.dark`, or `ThemeMode.system`.

```dart
// main.dart
MaterialApp(
  theme: ThemeData(
    colorScheme: ColorScheme.fromSeed(
      seedColor: Colors.deepPurple,
      brightness: Brightness.light,
    ),
    textTheme: const TextTheme(
      displayLarge: TextStyle(fontSize: 57.0, fontWeight: FontWeight.bold),
      bodyMedium: TextStyle(fontSize: 14.0, height: 1.4),
    ),
  ),
  darkTheme: ThemeData(
    colorScheme: ColorScheme.fromSeed(
      seedColor: Colors.deepPurple,
      brightness: Brightness.dark,
    ),
  ),
  home: const MyHomePage(),
);
```

### Implement Design Tokens with `ThemeExtension`

For custom styles that aren't part of the standard `ThemeData`, use
`ThemeExtension` to define reusable design tokens.

* **Create a Custom Theme Extension:** Define a class that extends
  `ThemeExtension<T>` and include your custom properties.
* **Implement `copyWith` and `lerp`:** These methods are required for the
  extension to work correctly with theme transitions.
* **Register in `ThemeData`:** Add your custom extension to the `extensions`
  list in your `ThemeData`.
* **Access Tokens in Widgets:** Use `Theme.of(context).extension<MyColors>()!`
  to access your custom tokens.

```dart
// 1. Define the extension
@immutable
class MyColors extends ThemeExtension<MyColors> {
  const MyColors({required this.success, required this.danger});

  final Color? success;
  final Color? danger;

  @override
  ThemeExtension<MyColors> copyWith({Color? success, Color? danger}) {
    return MyColors(success: success ?? this.success, danger: danger ?? this.danger);
  }

  @override
  ThemeExtension<MyColors> lerp(ThemeExtension<MyColors>? other, double t) {
    if (other is! MyColors) return this;
    return MyColors(
      success: Color.lerp(success, other.success, t),
      danger: Color.lerp(danger, other.danger, t),
    );
  }
}

// 2. Register it in ThemeData
theme: ThemeData(
  extensions: const <ThemeExtension<dynamic>>[
    MyColors(success: Colors.green, danger: Colors.red),
  ],
),

// 3. Use it in a widget
Container(
  color: Theme.of(context).extension<MyColors>()!.success,
)
```

### Styling with `WidgetStateProperty`

* **`WidgetStateProperty.resolveWith`:** Provide a function that receives a
  `Set<WidgetState>` and returns the appropriate value for the current state.
* **`WidgetStateProperty.all`:** A shorthand for when the value is the same for
  all states.

```dart
// Example: Creating a button style that changes color when pressed.
final ButtonStyle myButtonStyle = ButtonStyle(
  backgroundColor: WidgetStateProperty.resolveWith<Color>(
    (Set<WidgetState> states) {
      if (states.contains(WidgetState.pressed)) {
        return Colors.green; // Color when pressed
      }
      return Colors.red; // Default color
    },
  ),
);
```

## Layout Best Practices

### Building Flexible and Overflow-Safe Layouts

#### For Rows and Columns

* **`Expanded`:** Use to make a child widget fill the remaining available space
  along the main axis.
* **`Flexible`:** Use when you want a widget to shrink to fit, but not
  necessarily grow. Don't combine `Flexible` and `Expanded` in the same `Row` or
  `Column`.
* **`Wrap`:** Use when you have a series of widgets that would overflow a `Row`
  or `Column`, and you want them to move to the next line.

#### For General Content

* **`SingleChildScrollView`:** Use when your content is intrinsically larger
  than the viewport, but is a fixed size.
* **`ListView` / `GridView`:** For long lists or grids of content, always use a
  builder constructor (`.builder`).
* **`FittedBox`:** Use to scale or fit a single child widget within its parent.
* **`LayoutBuilder`:** Use for complex, responsive layouts to make decisions
  based on the available space.

### Layering Widgets with Stack

* **`Positioned`:** Use to precisely place a child within a `Stack` by anchoring it to the edges.
* **`Align`:** Use to position a child within a `Stack` using alignments like `Alignment.center`.

### Advanced Layout with Overlays

* **`OverlayPortal`:** Use this widget to show UI elements (like custom
  dropdowns or tooltips) "on top" of everything else. It manages the
  `OverlayEntry` for you.

  ```dart
  class MyDropdown extends StatefulWidget {
    const MyDropdown({super.key});

    @override
    State<MyDropdown> createState() => _MyDropdownState();
  }

  class _MyDropdownState extends State<MyDropdown> {
    final _controller = OverlayPortalController();

    @override
    Widget build(BuildContext context) {
      return OverlayPortal(
        controller: _controller,
        overlayChildBuilder: (BuildContext context) {
          return const Positioned(
            top: 50,
            left: 10,
            child: Card(
              child: Padding(
                padding: EdgeInsets.all(8.0),
                child: Text('I am an overlay!'),
              ),
            ),
          );
        },
        child: ElevatedButton(
          onPressed: _controller.toggle,
          child: const Text('Toggle Overlay'),
        ),
      );
    }
  }
  ```

## Color Scheme Best Practices

### Contrast Ratios

* **WCAG Guidelines:** Aim to meet the Web Content Accessibility Guidelines
  (WCAG) 2.1 standards.
* **Minimum Contrast:**
    * **Normal Text:** A contrast ratio of at least **4.5:1**.
    * **Large Text:** (18pt or 14pt bold) A contrast ratio of at least **3:1**.

### Palette Selection

* **Primary, Secondary, and Accent:** Define a clear color hierarchy.
* **The 60-30-10 Rule:** A classic design rule for creating a balanced color scheme.
    * **60%** Primary/Neutral Color (Dominant)
    * **30%** Secondary Color
    * **10%** Accent Color

### Complementary Colors

* **Use with Caution:** They can be visually jarring if overused.
* **Best Use Cases:** They are excellent for accent colors to make specific
  elements pop, but generally poor for text and background pairings as they can
  cause eye strain.

### Example Palette

* **Primary:** #0D47A1 (Dark Blue)
* **Secondary:** #1976D2 (Medium Blue)
* **Accent:** #FFC107 (Amber)
* **Neutral/Text:** #212121 (Almost Black)
* **Background:** #FEFEFE (Almost White)

## Font Best Practices

### Font Selection

* **Limit Font Families:** Stick to one or two font families for the entire
  application.
* **Prioritize Legibility:** Choose fonts that are easy to read on screens of
  all sizes. Sans-serif fonts are generally preferred for UI body text.
* **System Fonts:** Consider using platform-native system fonts.
* **Google Fonts:** For a wide selection of open-source fonts, use the
  `google_fonts` package.

### Hierarchy and Scale

* **Establish a Scale:** Define a set of font sizes for different text elements
  (e.g., headlines, titles, body text, captions).
* **Use Font Weight:** Differentiate text effectively using font weights.
* **Color and Opacity:** Use color and opacity to de-emphasize less important
  text.

### Readability

* **Line Height (Leading):** Set an appropriate line height, typically **1.4x to
  1.6x** the font size.
* **Line Length:** For body text, aim for a line length of **45-75 characters**.
* **Avoid All Caps:** Do not use all caps for long-form text.

### Example Typographic Scale

```dart
// In your ThemeData
textTheme: const TextTheme(
  displayLarge: TextStyle(fontSize: 57.0, fontWeight: FontWeight.bold),
  titleLarge: TextStyle(fontSize: 22.0, fontWeight: FontWeight.bold),
  bodyLarge: TextStyle(fontSize: 16.0, height: 1.5),
  bodyMedium: TextStyle(fontSize: 14.0, height: 1.4),
  labelSmall: TextStyle(fontSize: 11.0, color: Colors.grey),
),
```

## Documentation

* **`dartdoc`:** Write `dartdoc`-style comments for all public APIs.


### Documentation Philosophy

* **Comment wisely:** Use comments to explain why the code is written a certain
  way, not what the code does. The code itself should be self-explanatory.
* **Document for the user:** Write documentation with the reader in mind. If you
  had a question and found the answer, add it to the documentation where you
  first looked. This ensures the documentation answers real-world questions.
* **No useless documentation:** If the documentation only restates the obvious
  from the code's name, it's not helpful. Good documentation provides context
  and explains what isn't immediately apparent.
* **Consistency is key:** Use consistent terminology throughout your
  documentation.

### Commenting Style

* **Use `///` for doc comments:** This allows documentation generation tools to
  pick them up.
* **Start with a single-sentence summary:** The first sentence should be a
  concise, user-centric summary ending with a period.
* **Separate the summary:** Add a blank line after the first sentence to create
  a separate paragraph. This helps tools create better summaries.
* **Avoid redundancy:** Don't repeat information that's obvious from the code's
  context, like the class name or signature.
* **Don't document both getter and setter:** For properties with both, only
  document one. The documentation tool will treat them as a single field.

### Writing Style

* **Be brief:** Write concisely.
* **Avoid jargon and acronyms:** Don't use abbreviations unless they are widely
  understood.
* **Use Markdown sparingly:** Avoid excessive markdown and never use HTML for
  formatting.
* **Use backticks for code:** Enclose code blocks in backtick fences, and
  specify the language.

### What to Document

* **Public APIs are a priority:** Always document public APIs.
* **Consider private APIs:** It's a good idea to document private APIs as well.
* **Library-level comments are helpful:** Consider adding a doc comment at the
  library level to provide a general overview.
* **Include code samples:** Where appropriate, add code samples to illustrate usage.
* **Explain parameters, return values, and exceptions:** Use prose to describe
  what a function expects, what it returns, and what errors it might throw.
* **Place doc comments before annotations:** Documentation should come before
  any metadata annotations.

## Accessibility (A11Y)
Implement accessibility features to empower all users, assuming a wide variety
of users with different physical abilities, mental abilities, age groups,
education levels, and learning styles.

* **Color Contrast:** Ensure text has a contrast ratio of at least **4.5:1**
  against its background.
* **Dynamic Text Scaling:** Test your UI to ensure it remains usable when users
  increase the system font size.
* **Semantic Labels:** Use the `Semantics` widget to provide clear, descriptive
  labels for UI elements.
* **Screen Reader Testing:** Regularly test your app with TalkBack (Android) and
  VoiceOver (iOS).